bd7668d9e4fbb7aa83346006395be415
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

var _Track = _interopRequireDefault(require("./common/Track"));

var _createSlider = _interopRequireDefault(require("./common/createSlider"));

var utils = _interopRequireWildcard(require("./utils"));

function _createSuper(Derived) {
  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  return function () {
    var Super = (0, _getPrototypeOf2["default"])(Derived),
        result;

    if (isNativeReflectConstruct()) {
      var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return (0, _possibleConstructorReturn2["default"])(this, result);
  };
}

var Range =
/*#__PURE__*/
function (_Component) {
  (0, _inherits2["default"])(Range, _Component);

  var _super = _createSuper(Range);

  function Range(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, Range);
    _this = _super.call(this, props);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "onEnd", function () {
      _this.removeDocumentEvents();

      _this.props.onAfterChange(_this.getValue());
    });
    var count = props.count,
        min = props.min,
        max = props.max;
    var initialValue = Array.apply(null, Array(count + 1)).map(function () {
      return min;
    });
    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;
    var value = props.value !== undefined ? props.value : defaultValue;
    var bounds = value.map(function (v, i) {
      return _this.trimAlignValue(v, i);
    });
    var recent = bounds[0] === max ? 0 : bounds.length - 1;
    _this.state = {
      handle: null,
      recent: recent,
      bounds: bounds
    };
    return _this;
  }

  (0, _createClass2["default"])(Range, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      if (!('value' in nextProps || 'min' in nextProps || 'max' in nextProps)) return;

      if (this.props.min === nextProps.min && this.props.max === nextProps.max && (0, _isEqual["default"])(this.props.value, nextProps.value)) {
        return;
      }

      var bounds = this.state.bounds;
      var value = nextProps.value || bounds;
      var nextBounds = value.map(function (v, i) {
        return _this2.trimAlignValue(v, i, nextProps);
      });
      if (nextBounds.length === bounds.length && nextBounds.every(function (v, i) {
        return v === bounds[i];
      })) return;
      this.setState({
        bounds: nextBounds
      });

      if (bounds.some(function (v) {
        return utils.isValueOutOfRange(v, nextProps);
      })) {
        var newValues = value.map(function (v) {
          return utils.ensureValueInRange(v, nextProps);
        });
        this.props.onChange(newValues);
      }
    }
  }, {
    key: "onChange",
    value: function onChange(state) {
      var props = this.props;
      var isNotControlled = !('value' in props);

      if (isNotControlled) {
        this.setState(state);
      } else if (state.handle !== undefined) {
        this.setState({
          handle: state.handle
        });
      }

      var data = (0, _objectSpread2["default"])({}, this.state, {}, state);
      var changedValue = data.bounds;
      props.onChange(changedValue);
    }
  }, {
    key: "onStart",
    value: function onStart(position) {
      var props = this.props;
      var state = this.state;
      var bounds = this.getValue();
      props.onBeforeChange(bounds);
      var value = this.calcValueByPos(position);
      this.startValue = value;
      this.startPosition = position;
      var closestBound = this.getClosestBound(value);
      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);
      this.setState({
        handle: this.prevMovedHandleIndex,
        recent: this.prevMovedHandleIndex
      });
      var prevValue = bounds[this.prevMovedHandleIndex];
      if (value === prevValue) return;
      var nextBounds = (0, _toConsumableArray2["default"])(state.bounds);
      nextBounds[this.prevMovedHandleIndex] = value;
      this.onChange({
        bounds: nextBounds
      });
    }
  }, {
    key: "onMove",
    value: function onMove(e, position) {
      utils.pauseEvent(e);
      var state = this.state;
      var value = this.calcValueByPos(position);
      var oldValue = state.bounds[state.handle];
      if (value === oldValue) return;
      this.moveTo(value);
    }
  }, {
    key: "onKeyboard",
    value: function onKeyboard(e) {
      var valueMutator = utils.getKeyboardValueMutator(e);

      if (valueMutator) {
        utils.pauseEvent(e);
        var state = this.state,
            props = this.props;
        var bounds = state.bounds,
            handle = state.handle;
        var oldValue = bounds[handle];
        var mutatedValue = valueMutator(oldValue, props);
        var value = this.trimAlignValue(mutatedValue);
        if (value === oldValue) return;
        var isFromKeyboardEvent = true;
        this.moveTo(value, isFromKeyboardEvent);
      }
    }
  }, {
    key: "getValue",
    value: function getValue() {
      return this.state.bounds;
    }
  }, {
    key: "getClosestBound",
    value: function getClosestBound(value) {
      var bounds = this.state.bounds;
      var closestBound = 0;

      for (var i = 1; i < bounds.length - 1; ++i) {
        if (value > bounds[i]) {
          closestBound = i;
        }
      }

      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {
        closestBound = closestBound + 1;
      }

      return closestBound;
    }
  }, {
    key: "getBoundNeedMoving",
    value: function getBoundNeedMoving(value, closestBound) {
      var _this$state = this.state,
          bounds = _this$state.bounds,
          recent = _this$state.recent;
      var boundNeedMoving = closestBound;
      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];

      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {
        boundNeedMoving = recent;
      }

      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {
        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;
      }

      return boundNeedMoving;
    }
  }, {
    key: "getLowerBound",
    value: function getLowerBound() {
      return this.state.bounds[0];
    }
  }, {
    key: "getUpperBound",
    value: function getUpperBound() {
      var bounds = this.state.bounds;
      return bounds[bounds.length - 1];
    }
    /**
     * Returns an array of possible slider points, taking into account both
     * `marks` and `step`. The result is cached.
     */

  }, {
    key: "getPoints",
    value: function getPoints() {
      var _this$props = this.props,
          marks = _this$props.marks,
          step = _this$props.step,
          min = _this$props.min,
          max = _this$props.max;
      var cache = this._getPointsCache;

      if (!cache || cache.marks !== marks || cache.step !== step) {
        var pointsObject = (0, _objectSpread2["default"])({}, marks);

        if (step !== null) {
          for (var point = min; point <= max; point += step) {
            pointsObject[point] = point;
          }
        }

        var points = Object.keys(pointsObject).map(parseFloat);
        points.sort(function (a, b) {
          return a - b;
        });
        this._getPointsCache = {
          marks: marks,
          step: step,
          points: points
        };
      }

      return this._getPointsCache.points;
    }
  }, {
    key: "moveTo",
    value: function moveTo(value, isFromKeyboardEvent) {
      var _this3 = this;

      var state = this.state,
          props = this.props;
      var nextBounds = (0, _toConsumableArray2["default"])(state.bounds);
      nextBounds[state.handle] = value;
      var nextHandle = state.handle;

      if (props.pushable !== false) {
        this.pushSurroundingHandles(nextBounds, nextHandle);
      } else if (props.allowCross) {
        nextBounds.sort(function (a, b) {
          return a - b;
        });
        nextHandle = nextBounds.indexOf(value);
      }

      this.onChange({
        handle: nextHandle,
        bounds: nextBounds
      });

      if (isFromKeyboardEvent) {
        // known problem: because setState is async,
        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,
        // cause onBeforeChange and onAfterChange receive wrong value.
        // here use setState callback to hackï¼Œbut not elegant
        this.setState({}, function () {
          _this3.handlesRefs[nextHandle].focus();
        });
      }
    }
  }, {
    key: "pushSurroundingHandles",
    value: function pushSurroundingHandles(bounds, handle) {
      var value = bounds[handle];
      var threshold = this.props.pushable;
      threshold = Number(threshold);
      var direction = 0;

      if (bounds[handle + 1] - value < threshold) {
        direction = +1; // push to right
      }

      if (value - bounds[handle - 1] < threshold) {
        direction = -1; // push to left
      }

      if (direction === 0) {
        return;
      }

      var nextHandle = handle + direction;
      var diffToNext = direction * (bounds[nextHandle] - value);

      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {
        // revert to original value if pushing is impossible
        bounds[handle] = bounds[nextHandle] - direction * threshold;
      }
    }
  }, {
    key: "pushHandle",
    value: function pushHandle(bounds, handle, direction, amount) {
      var originalValue = bounds[handle];
      var currentValue = bounds[handle];

      while (direction * (currentValue - originalValue) < amount) {
        if (!this.pushHandleOnePoint(bounds, handle, direction)) {
          // can't push handle enough to create the needed `amount` gap, so we
          // revert its position to the original value
          bounds[handle] = originalValue;
          return false;
        }

        currentValue = bounds[handle];
      } // the handle was pushed enough to create the needed `amount` gap


      return true;
    }
  }, {
    key: "pushHandleOnePoint",
    value: function pushHandleOnePoint(bounds, handle, direction) {
      var points = this.getPoints();
      var pointIndex = points.indexOf(bounds[handle]);
      var nextPointIndex = pointIndex + direction;

      if (nextPointIndex >= points.length || nextPointIndex < 0) {
        // reached the minimum or maximum available point, can't push anymore
        return false;
      }

      var nextHandle = handle + direction;
      var nextValue = points[nextPointIndex];
      var threshold = this.props.pushable;
      var diffToNext = direction * (bounds[nextHandle] - nextValue);

      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {
        // couldn't push next handle, so we won't push this one either
        return false;
      } // push the handle


      bounds[handle] = nextValue;
      return true;
    }
  }, {
    key: "trimAlignValue",
    value: function trimAlignValue(v, handle) {
      var nextProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var mergedProps = (0, _objectSpread2["default"])({}, this.props, {}, nextProps);
      var valInRange = utils.ensureValueInRange(v, mergedProps);
      var valNotConflict = this.ensureValueNotConflict(handle, valInRange, mergedProps);
      return utils.ensureValuePrecision(valNotConflict, mergedProps);
    }
  }, {
    key: "ensureValueNotConflict",
    value: function ensureValueNotConflict(handle, val, _ref) {
      var allowCross = _ref.allowCross,
          thershold = _ref.pushable;
      var state = this.state || {};
      var bounds = state.bounds;
      handle = handle === undefined ? state.handle : handle;
      thershold = Number(thershold);
      /* eslint-disable eqeqeq */

      if (!allowCross && handle != null && bounds !== undefined) {
        if (handle > 0 && val <= bounds[handle - 1] + thershold) {
          return bounds[handle - 1] + thershold;
        }

        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {
          return bounds[handle + 1] - thershold;
        }
      }
      /* eslint-enable eqeqeq */


      return val;
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var _this$state2 = this.state,
          handle = _this$state2.handle,
          bounds = _this$state2.bounds;
      var _this$props2 = this.props,
          prefixCls = _this$props2.prefixCls,
          vertical = _this$props2.vertical,
          included = _this$props2.included,
          disabled = _this$props2.disabled,
          min = _this$props2.min,
          max = _this$props2.max,
          handleGenerator = _this$props2.handle,
          trackStyle = _this$props2.trackStyle,
          handleStyle = _this$props2.handleStyle,
          tabIndex = _this$props2.tabIndex;
      var offsets = bounds.map(function (v) {
        return _this4.calcOffset(v);
      });
      var handleClassName = "".concat(prefixCls, "-handle");
      var handles = bounds.map(function (v, i) {
        var _classNames;

        return handleGenerator({
          className: (0, _classnames["default"])((_classNames = {}, (0, _defineProperty2["default"])(_classNames, handleClassName, true), (0, _defineProperty2["default"])(_classNames, "".concat(handleClassName, "-").concat(i + 1), true), _classNames)),
          prefixCls: prefixCls,
          vertical: vertical,
          offset: offsets[i],
          value: v,
          dragging: handle === i,
          index: i,
          tabIndex: tabIndex[i] || 0,
          min: min,
          max: max,
          disabled: disabled,
          style: handleStyle[i],
          ref: function ref(h) {
            return _this4.saveHandle(i, h);
          }
        });
      });
      var tracks = bounds.slice(0, -1).map(function (_, index) {
        var _classNames2;

        var i = index + 1;
        var trackClassName = (0, _classnames["default"])((_classNames2 = {}, (0, _defineProperty2["default"])(_classNames2, "".concat(prefixCls, "-track"), true), (0, _defineProperty2["default"])(_classNames2, "".concat(prefixCls, "-track-").concat(i), true), _classNames2));
        return _react["default"].createElement(_Track["default"], {
          className: trackClassName,
          vertical: vertical,
          included: included,
          offset: offsets[i - 1],
          length: offsets[i] - offsets[i - 1],
          style: trackStyle[index],
          key: i
        });
      });
      return {
        tracks: tracks,
        handles: handles
      };
    }
  }]);
  return Range;
}(_react.Component);

(0, _defineProperty2["default"])(Range, "displayName", 'Range');
(0, _defineProperty2["default"])(Range, "propTypes", {
  defaultValue: _propTypes["default"].arrayOf(_propTypes["default"].number),
  value: _propTypes["default"].arrayOf(_propTypes["default"].number),
  count: _propTypes["default"].number,
  pushable: _propTypes["default"].oneOfType([_propTypes["default"].bool, _propTypes["default"].number]),
  allowCross: _propTypes["default"].bool,
  disabled: _propTypes["default"].bool,
  tabIndex: _propTypes["default"].arrayOf(_propTypes["default"].number)
});
(0, _defineProperty2["default"])(Range, "defaultProps", {
  count: 1,
  allowCross: true,
  pushable: false,
  tabIndex: []
});

var _default = (0, _createSlider["default"])(Range);

exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJhbmdlLmpzeCJdLCJuYW1lcyI6WyJSYW5nZSIsInByb3BzIiwicmVtb3ZlRG9jdW1lbnRFdmVudHMiLCJvbkFmdGVyQ2hhbmdlIiwiZ2V0VmFsdWUiLCJjb3VudCIsIm1pbiIsIm1heCIsImluaXRpYWxWYWx1ZSIsIkFycmF5IiwiYXBwbHkiLCJtYXAiLCJkZWZhdWx0VmFsdWUiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImJvdW5kcyIsInYiLCJpIiwidHJpbUFsaWduVmFsdWUiLCJyZWNlbnQiLCJsZW5ndGgiLCJzdGF0ZSIsImhhbmRsZSIsIm5leHRQcm9wcyIsIm5leHRCb3VuZHMiLCJldmVyeSIsInNldFN0YXRlIiwic29tZSIsInV0aWxzIiwiaXNWYWx1ZU91dE9mUmFuZ2UiLCJuZXdWYWx1ZXMiLCJlbnN1cmVWYWx1ZUluUmFuZ2UiLCJvbkNoYW5nZSIsImlzTm90Q29udHJvbGxlZCIsImRhdGEiLCJjaGFuZ2VkVmFsdWUiLCJwb3NpdGlvbiIsIm9uQmVmb3JlQ2hhbmdlIiwiY2FsY1ZhbHVlQnlQb3MiLCJzdGFydFZhbHVlIiwic3RhcnRQb3NpdGlvbiIsImNsb3Nlc3RCb3VuZCIsImdldENsb3Nlc3RCb3VuZCIsInByZXZNb3ZlZEhhbmRsZUluZGV4IiwiZ2V0Qm91bmROZWVkTW92aW5nIiwicHJldlZhbHVlIiwiZSIsInBhdXNlRXZlbnQiLCJvbGRWYWx1ZSIsIm1vdmVUbyIsInZhbHVlTXV0YXRvciIsImdldEtleWJvYXJkVmFsdWVNdXRhdG9yIiwibXV0YXRlZFZhbHVlIiwiaXNGcm9tS2V5Ym9hcmRFdmVudCIsIk1hdGgiLCJhYnMiLCJib3VuZE5lZWRNb3ZpbmciLCJpc0F0VGhlU2FtZVBvaW50IiwibWFya3MiLCJzdGVwIiwiY2FjaGUiLCJfZ2V0UG9pbnRzQ2FjaGUiLCJwb2ludHNPYmplY3QiLCJwb2ludCIsInBvaW50cyIsIk9iamVjdCIsImtleXMiLCJwYXJzZUZsb2F0Iiwic29ydCIsImEiLCJiIiwibmV4dEhhbmRsZSIsInB1c2hhYmxlIiwicHVzaFN1cnJvdW5kaW5nSGFuZGxlcyIsImFsbG93Q3Jvc3MiLCJpbmRleE9mIiwiaGFuZGxlc1JlZnMiLCJmb2N1cyIsInRocmVzaG9sZCIsIk51bWJlciIsImRpcmVjdGlvbiIsImRpZmZUb05leHQiLCJwdXNoSGFuZGxlIiwiYW1vdW50Iiwib3JpZ2luYWxWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsInB1c2hIYW5kbGVPbmVQb2ludCIsImdldFBvaW50cyIsInBvaW50SW5kZXgiLCJuZXh0UG9pbnRJbmRleCIsIm5leHRWYWx1ZSIsIm1lcmdlZFByb3BzIiwidmFsSW5SYW5nZSIsInZhbE5vdENvbmZsaWN0IiwiZW5zdXJlVmFsdWVOb3RDb25mbGljdCIsImVuc3VyZVZhbHVlUHJlY2lzaW9uIiwidmFsIiwidGhlcnNob2xkIiwicHJlZml4Q2xzIiwidmVydGljYWwiLCJpbmNsdWRlZCIsImRpc2FibGVkIiwiaGFuZGxlR2VuZXJhdG9yIiwidHJhY2tTdHlsZSIsImhhbmRsZVN0eWxlIiwidGFiSW5kZXgiLCJvZmZzZXRzIiwiY2FsY09mZnNldCIsImhhbmRsZUNsYXNzTmFtZSIsImhhbmRsZXMiLCJjbGFzc05hbWUiLCJvZmZzZXQiLCJkcmFnZ2luZyIsImluZGV4Iiwic3R5bGUiLCJyZWYiLCJoIiwic2F2ZUhhbmRsZSIsInRyYWNrcyIsInNsaWNlIiwiXyIsInRyYWNrQ2xhc3NOYW1lIiwiQ29tcG9uZW50IiwiUHJvcFR5cGVzIiwiYXJyYXlPZiIsIm51bWJlciIsIm9uZU9mVHlwZSIsImJvb2wiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFTUEsSzs7Ozs7OztBQXNCSixpQkFBWUMsS0FBWixFQUFtQjtBQUFBOztBQUFBO0FBQ2pCLDhCQUFNQSxLQUFOO0FBRGlCLDhGQW1GWCxZQUFNO0FBQ1osWUFBS0Msb0JBQUw7O0FB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Q0FBQyxHQUFHLENBQUwsQ0FMOUI7QUFNRSxVQUFBLEtBQUssRUFBRXNGLFVBQVUsQ0FBQ1UsS0FBRCxDQU5uQjtBQU9FLFVBQUEsR0FBRyxFQUFFaEc7QUFQUCxVQURGO0FBV0QsT0FqQmMsQ0FBZjtBQW1CQSxhQUFPO0FBQUVxRyxRQUFBQSxNQUFNLEVBQU5BLE1BQUY7QUFBVVQsUUFBQUEsT0FBTyxFQUFQQTtBQUFWLE9BQVA7QUFDRDs7O0VBalhpQmEsZ0I7O2lDQUFkMUgsSyxpQkFDaUIsTztpQ0FEakJBLEssZUFFZTtBQUNqQlksRUFBQUEsWUFBWSxFQUFFK0csc0JBQVVDLE9BQVYsQ0FBa0JELHNCQUFVRSxNQUE1QixDQURHO0FBRWpCaEgsRUFBQUEsS0FBSyxFQUFFOEcsc0JBQVVDLE9BQVYsQ0FBa0JELHNCQUFVRSxNQUE1QixDQUZVO0FBR2pCeEgsRUFBQUEsS0FBSyxFQUFFc0gsc0JBQVVFLE1BSEE7QUFJakJyRCxFQUFBQSxRQUFRLEVBQUVtRCxzQkFBVUcsU0FBVixDQUFvQixDQUM1Qkgsc0JBQVVJLElBRGtCLEVBRTVCSixzQkFBVUUsTUFGa0IsQ0FBcEIsQ0FKTztBQVFqQm5ELEVBQUFBLFVBQVUsRUFBRWlELHNCQUFVSSxJQVJMO0FBU2pCMUIsRUFBQUEsUUFBUSxFQUFFc0Isc0JBQVVJLElBVEg7QUFVakJ0QixFQUFBQSxRQUFRLEVBQUVrQixzQkFBVUMsT0FBVixDQUFrQkQsc0JBQVVFLE1BQTVCO0FBVk8sQztpQ0FGZjdILEssa0JBZWtCO0FBQ3BCSyxFQUFBQSxLQUFLLEVBQUUsQ0FEYTtBQUVwQnFFLEVBQUFBLFVBQVUsRUFBRSxJQUZRO0FBR3BCRixFQUFBQSxRQUFRLEVBQUUsS0FIVTtBQUlwQmlDLEVBQUFBLFFBQVEsRUFBRTtBQUpVLEM7O2VBcVdULDhCQUFhekcsS0FBYixDIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJvcC10eXBlcyAqL1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnbG9kYXNoL2lzRXF1YWwnO1xuaW1wb3J0IFRyYWNrIGZyb20gJy4vY29tbW9uL1RyYWNrJztcbmltcG9ydCBjcmVhdGVTbGlkZXIgZnJvbSAnLi9jb21tb24vY3JlYXRlU2xpZGVyJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vdXRpbHMnO1xuXG5jbGFzcyBSYW5nZSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHN0YXRpYyBkaXNwbGF5TmFtZSA9ICdSYW5nZSc7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKSxcbiAgICB2YWx1ZTogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlciksXG4gICAgY291bnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgcHVzaGFibGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgUHJvcFR5cGVzLmJvb2wsXG4gICAgICBQcm9wVHlwZXMubnVtYmVyLFxuICAgIF0pLFxuICAgIGFsbG93Q3Jvc3M6IFByb3BUeXBlcy5ib29sLFxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICB0YWJJbmRleDogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlciksXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb3VudDogMSxcbiAgICBhbGxvd0Nyb3NzOiB0cnVlLFxuICAgIHB1c2hhYmxlOiBmYWxzZSxcbiAgICB0YWJJbmRleDogW10sXG4gIH07XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICBjb25zdCB7IGNvdW50LCBtaW4sIG1heCB9ID0gcHJvcHM7XG4gICAgY29uc3QgaW5pdGlhbFZhbHVlID0gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkoY291bnQgKyAxKSlcbiAgICAgICAgICAgIC5tYXAoKCkgPT4gbWluKTtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSAnZGVmYXVsdFZhbHVlJyBpbiBwcm9wcyA/XG4gICAgICAgICAgICBwcm9wcy5kZWZhdWx0VmFsdWUgOiBpbml0aWFsVmFsdWU7XG4gICAgY29uc3QgdmFsdWUgPSBwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlO1xuICAgIGNvbnN0IGJvdW5kcyA9IHZhbHVlLm1hcCgodiwgaSkgPT4gdGhpcy50cmltQWxpZ25WYWx1ZSh2LCBpKSk7XG4gICAgY29uc3QgcmVjZW50ID0gYm91bmRzWzBdID09PSBtYXggPyAwIDogYm91bmRzLmxlbmd0aCAtIDE7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaGFuZGxlOiBudWxsLFxuICAgICAgcmVjZW50LFxuICAgICAgYm91bmRzLFxuICAgIH07XG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmICghKCd2YWx1ZScgaW4gbmV4dFByb3BzIHx8ICdtaW4nIGluIG5leHRQcm9wcyB8fCAnbWF4JyBpbiBuZXh0UHJvcHMpKSByZXR1cm47XG4gICAgaWYgKHRoaXMucHJvcHMubWluID09PSBuZXh0UHJvcHMubWluICYmXG4gICAgICAgIHRoaXMucHJvcHMubWF4ID09PSBuZXh0UHJvcHMubWF4ICYmXG4gICAgICAgIHNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLnZhbHVlLCBuZXh0UHJvcHMudmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBib3VuZHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgdmFsdWUgPSBuZXh0UHJvcHMudmFsdWUgfHwgYm91bmRzO1xuICAgIGNvbnN0IG5leHRCb3VuZHMgPSB2YWx1ZS5tYXAoKHYsIGkpID0+IHRoaXMudHJpbUFsaWduVmFsdWUodiwgaSwgbmV4dFByb3BzKSk7XG4gICAgaWYgKG5leHRCb3VuZHMubGVuZ3RoID09PSBib3VuZHMubGVuZ3RoICYmIG5leHRCb3VuZHMuZXZlcnkoKHYsIGkpID0+IHYgPT09IGJvdW5kc1tpXSkpIHJldHVybjtcblxuICAgIHRoaXMuc2V0U3RhdGUoeyBib3VuZHM6IG5leHRCb3VuZHMgfSk7XG5cbiAgICBpZiAoYm91bmRzLnNvbWUodiA9PiB1dGlscy5pc1ZhbHVlT3V0T2ZSYW5nZSh2LCBuZXh0UHJvcHMpKSkge1xuICAgICAgY29uc3QgbmV3VmFsdWVzID0gdmFsdWUubWFwKCh2KSA9PiB7XG4gICAgICAgIHJldHVybiB1dGlscy5lbnN1cmVWYWx1ZUluUmFuZ2UodiwgbmV4dFByb3BzKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShuZXdWYWx1ZXMpO1xuICAgIH1cbiAgfVxuXG4gIG9uQ2hhbmdlKHN0YXRlKSB7XG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGlzTm90Q29udHJvbGxlZCA9ICEoJ3ZhbHVlJyBpbiBwcm9wcyk7XG4gICAgaWYgKGlzTm90Q29udHJvbGxlZCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5oYW5kbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGhhbmRsZTogc3RhdGUuaGFuZGxlIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSB7IC4uLnRoaXMuc3RhdGUsIC4uLnN0YXRlIH07XG4gICAgY29uc3QgY2hhbmdlZFZhbHVlID0gZGF0YS5ib3VuZHM7XG4gICAgcHJvcHMub25DaGFuZ2UoY2hhbmdlZFZhbHVlKTtcbiAgfVxuXG4gIG9uU3RhcnQocG9zaXRpb24pIHtcbiAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICBwcm9wcy5vbkJlZm9yZUNoYW5nZShib3VuZHMpO1xuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmNhbGNWYWx1ZUJ5UG9zKHBvc2l0aW9uKTtcbiAgICB0aGlzLnN0YXJ0VmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBwb3NpdGlvbjtcblxuICAgIGNvbnN0IGNsb3Nlc3RCb3VuZCA9IHRoaXMuZ2V0Q2xvc2VzdEJvdW5kKHZhbHVlKTtcbiAgICB0aGlzLnByZXZNb3ZlZEhhbmRsZUluZGV4ID0gdGhpcy5nZXRCb3VuZE5lZWRNb3ZpbmcodmFsdWUsIGNsb3Nlc3RCb3VuZCk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGhhbmRsZTogdGhpcy5wcmV2TW92ZWRIYW5kbGVJbmRleCxcbiAgICAgIHJlY2VudDogdGhpcy5wcmV2TW92ZWRIYW5kbGVJbmRleCxcbiAgICB9KTtcblxuICAgIGNvbnN0IHByZXZWYWx1ZSA9IGJvdW5kc1t0aGlzLnByZXZNb3ZlZEhhbmRsZUluZGV4XTtcbiAgICBpZiAodmFsdWUgPT09IHByZXZWYWx1ZSkgcmV0dXJuO1xuXG4gICAgY29uc3QgbmV4dEJvdW5kcyA9IFsuLi5zdGF0ZS5ib3VuZHNdO1xuICAgIG5leHRCb3VuZHNbdGhpcy5wcmV2TW92ZWRIYW5kbGVJbmRleF0gPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlKHsgYm91bmRzOiBuZXh0Qm91bmRzIH0pO1xuICB9XG5cbiAgb25FbmQgPSAoKSA9PiB7XG4gICAgdGhpcy5yZW1vdmVEb2N1bWVudEV2ZW50cygpO1xuICAgIHRoaXMucHJvcHMub25BZnRlckNoYW5nZSh0aGlzLmdldFZhbHVlKCkpO1xuICB9XG5cbiAgb25Nb3ZlKGUsIHBvc2l0aW9uKSB7XG4gICAgdXRpbHMucGF1c2VFdmVudChlKTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuY2FsY1ZhbHVlQnlQb3MocG9zaXRpb24pO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gc3RhdGUuYm91bmRzW3N0YXRlLmhhbmRsZV07XG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgcmV0dXJuO1xuXG4gICAgdGhpcy5tb3ZlVG8odmFsdWUpO1xuICB9XG5cbiAgb25LZXlib2FyZChlKSB7XG4gICAgY29uc3QgdmFsdWVNdXRhdG9yID0gdXRpbHMuZ2V0S2V5Ym9hcmRWYWx1ZU11dGF0b3IoZSk7XG5cbiAgICBpZiAodmFsdWVNdXRhdG9yKSB7XG4gICAgICB1dGlscy5wYXVzZUV2ZW50KGUpO1xuICAgICAgY29uc3QgeyBzdGF0ZSwgcHJvcHMgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7IGJvdW5kcywgaGFuZGxlIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gYm91bmRzW2hhbmRsZV07XG4gICAgICBjb25zdCBtdXRhdGVkVmFsdWUgPSB2YWx1ZU11dGF0b3Iob2xkVmFsdWUsIHByb3BzKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy50cmltQWxpZ25WYWx1ZShtdXRhdGVkVmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgcmV0dXJuO1xuICAgICAgY29uc3QgaXNGcm9tS2V5Ym9hcmRFdmVudCA9IHRydWU7XG4gICAgICB0aGlzLm1vdmVUbyh2YWx1ZSwgaXNGcm9tS2V5Ym9hcmRFdmVudCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuYm91bmRzO1xuICB9XG5cbiAgZ2V0Q2xvc2VzdEJvdW5kKHZhbHVlKSB7XG4gICAgY29uc3QgeyBib3VuZHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IGNsb3Nlc3RCb3VuZCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBib3VuZHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBpZiAodmFsdWUgPiBib3VuZHNbaV0pIHsgY2xvc2VzdEJvdW5kID0gaTsgfVxuICAgIH1cbiAgICBpZiAoTWF0aC5hYnMoYm91bmRzW2Nsb3Nlc3RCb3VuZCArIDFdIC0gdmFsdWUpIDwgTWF0aC5hYnMoYm91bmRzW2Nsb3Nlc3RCb3VuZF0gLSB2YWx1ZSkpIHtcbiAgICAgIGNsb3Nlc3RCb3VuZCA9IGNsb3Nlc3RCb3VuZCArIDE7XG4gICAgfVxuICAgIHJldHVybiBjbG9zZXN0Qm91bmQ7XG4gIH1cblxuICBnZXRCb3VuZE5lZWRNb3ZpbmcodmFsdWUsIGNsb3Nlc3RCb3VuZCkge1xuICAgIGNvbnN0IHsgYm91bmRzLCByZWNlbnQgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IGJvdW5kTmVlZE1vdmluZyA9IGNsb3Nlc3RCb3VuZDtcbiAgICBjb25zdCBpc0F0VGhlU2FtZVBvaW50ID0gKGJvdW5kc1tjbG9zZXN0Qm91bmQgKyAxXSA9PT0gYm91bmRzW2Nsb3Nlc3RCb3VuZF0pO1xuXG4gICAgaWYgKGlzQXRUaGVTYW1lUG9pbnQgJiYgYm91bmRzW3JlY2VudF0gPT09IGJvdW5kc1tjbG9zZXN0Qm91bmRdKSB7XG4gICAgICBib3VuZE5lZWRNb3ZpbmcgPSByZWNlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGlzQXRUaGVTYW1lUG9pbnQgJiYgKHZhbHVlICE9PSBib3VuZHNbY2xvc2VzdEJvdW5kICsgMV0pKSB7XG4gICAgICBib3VuZE5lZWRNb3ZpbmcgPSB2YWx1ZSA8IGJvdW5kc1tjbG9zZXN0Qm91bmQgKyAxXSA/IGNsb3Nlc3RCb3VuZCA6IGNsb3Nlc3RCb3VuZCArIDE7XG4gICAgfVxuICAgIHJldHVybiBib3VuZE5lZWRNb3Zpbmc7XG4gIH1cblxuICBnZXRMb3dlckJvdW5kKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmJvdW5kc1swXTtcbiAgfVxuXG4gIGdldFVwcGVyQm91bmQoKSB7XG4gICAgY29uc3QgeyBib3VuZHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgcmV0dXJuIGJvdW5kc1tib3VuZHMubGVuZ3RoIC0gMV07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBwb3NzaWJsZSBzbGlkZXIgcG9pbnRzLCB0YWtpbmcgaW50byBhY2NvdW50IGJvdGhcbiAgICogYG1hcmtzYCBhbmQgYHN0ZXBgLiBUaGUgcmVzdWx0IGlzIGNhY2hlZC5cbiAgICovXG4gIGdldFBvaW50cygpIHtcbiAgICBjb25zdCB7IG1hcmtzLCBzdGVwLCBtaW4sIG1heCB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2dldFBvaW50c0NhY2hlO1xuICAgIGlmICghY2FjaGUgfHwgY2FjaGUubWFya3MgIT09IG1hcmtzIHx8IGNhY2hlLnN0ZXAgIT09IHN0ZXApIHtcbiAgICAgIGNvbnN0IHBvaW50c09iamVjdCA9IHsgLi4ubWFya3MgfTtcbiAgICAgIGlmIChzdGVwICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAobGV0IHBvaW50ID0gbWluOyBwb2ludCA8PSBtYXg7IHBvaW50ICs9IHN0ZXApIHtcbiAgICAgICAgICBwb2ludHNPYmplY3RbcG9pbnRdID0gcG9pbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvaW50cyA9IE9iamVjdC5rZXlzKHBvaW50c09iamVjdCkubWFwKHBhcnNlRmxvYXQpO1xuICAgICAgcG9pbnRzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgIHRoaXMuX2dldFBvaW50c0NhY2hlID0geyBtYXJrcywgc3RlcCwgcG9pbnRzIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nZXRQb2ludHNDYWNoZS5wb2ludHM7XG4gIH1cblxuICBtb3ZlVG8odmFsdWUsIGlzRnJvbUtleWJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCB7IHN0YXRlLCBwcm9wcyB9ID0gdGhpcztcbiAgICBjb25zdCBuZXh0Qm91bmRzID0gWy4uLnN0YXRlLmJvdW5kc107XG4gICAgbmV4dEJvdW5kc1tzdGF0ZS5oYW5kbGVdID0gdmFsdWU7XG4gICAgbGV0IG5leHRIYW5kbGUgPSBzdGF0ZS5oYW5kbGU7XG4gICAgaWYgKHByb3BzLnB1c2hhYmxlICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5wdXNoU3Vycm91bmRpbmdIYW5kbGVzKG5leHRCb3VuZHMsIG5leHRIYW5kbGUpO1xuICAgIH0gZWxzZSBpZiAocHJvcHMuYWxsb3dDcm9zcykge1xuICAgICAgbmV4dEJvdW5kcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICBuZXh0SGFuZGxlID0gbmV4dEJvdW5kcy5pbmRleE9mKHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5vbkNoYW5nZSh7XG4gICAgICBoYW5kbGU6IG5leHRIYW5kbGUsXG4gICAgICBib3VuZHM6IG5leHRCb3VuZHMsXG4gICAgfSk7XG4gICAgaWYgKGlzRnJvbUtleWJvYXJkRXZlbnQpIHtcbiAgICAgIC8vIGtub3duIHByb2JsZW06IGJlY2F1c2Ugc2V0U3RhdGUgaXMgYXN5bmMsXG4gICAgICAvLyBzbyB0cmlnZ2VyIGZvY3VzIHdpbGwgaW52b2tlIGhhbmRsZXIncyBvbkVuZCBhbmQgYW5vdGhlciBoYW5kbGVyJ3Mgb25TdGFydCB0b28gZWFybHksXG4gICAgICAvLyBjYXVzZSBvbkJlZm9yZUNoYW5nZSBhbmQgb25BZnRlckNoYW5nZSByZWNlaXZlIHdyb25nIHZhbHVlLlxuICAgICAgLy8gaGVyZSB1c2Ugc2V0U3RhdGUgY2FsbGJhY2sgdG8gaGFja++8jGJ1dCBub3QgZWxlZ2FudFxuICAgICAgdGhpcy5zZXRTdGF0ZSh7fSwgKCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZXNSZWZzW25leHRIYW5kbGVdLmZvY3VzKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwdXNoU3Vycm91bmRpbmdIYW5kbGVzKGJvdW5kcywgaGFuZGxlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBib3VuZHNbaGFuZGxlXTtcbiAgICBsZXQgeyBwdXNoYWJsZTogdGhyZXNob2xkIH0gPSB0aGlzLnByb3BzO1xuICAgIHRocmVzaG9sZCA9IE51bWJlcih0aHJlc2hvbGQpO1xuXG4gICAgbGV0IGRpcmVjdGlvbiA9IDA7XG4gICAgaWYgKGJvdW5kc1toYW5kbGUgKyAxXSAtIHZhbHVlIDwgdGhyZXNob2xkKSB7XG4gICAgICBkaXJlY3Rpb24gPSArMTsgLy8gcHVzaCB0byByaWdodFxuICAgIH1cbiAgICBpZiAodmFsdWUgLSBib3VuZHNbaGFuZGxlIC0gMV0gPCB0aHJlc2hvbGQpIHtcbiAgICAgIGRpcmVjdGlvbiA9IC0xOyAvLyBwdXNoIHRvIGxlZnRcbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSAwKSB7IHJldHVybjsgfVxuXG4gICAgY29uc3QgbmV4dEhhbmRsZSA9IGhhbmRsZSArIGRpcmVjdGlvbjtcbiAgICBjb25zdCBkaWZmVG9OZXh0ID0gZGlyZWN0aW9uICogKGJvdW5kc1tuZXh0SGFuZGxlXSAtIHZhbHVlKTtcbiAgICBpZiAoIXRoaXMucHVzaEhhbmRsZShib3VuZHMsIG5leHRIYW5kbGUsIGRpcmVjdGlvbiwgdGhyZXNob2xkIC0gZGlmZlRvTmV4dCkpIHtcbiAgICAgIC8vIHJldmVydCB0byBvcmlnaW5hbCB2YWx1ZSBpZiBwdXNoaW5nIGlzIGltcG9zc2libGVcbiAgICAgIGJvdW5kc1toYW5kbGVdID0gYm91bmRzW25leHRIYW5kbGVdIC0gKGRpcmVjdGlvbiAqIHRocmVzaG9sZCk7XG4gICAgfVxuICB9XG5cbiAgcHVzaEhhbmRsZShib3VuZHMsIGhhbmRsZSwgZGlyZWN0aW9uLCBhbW91bnQpIHtcbiAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gYm91bmRzW2hhbmRsZV07XG4gICAgbGV0IGN1cnJlbnRWYWx1ZSA9IGJvdW5kc1toYW5kbGVdO1xuICAgIHdoaWxlIChkaXJlY3Rpb24gKiAoY3VycmVudFZhbHVlIC0gb3JpZ2luYWxWYWx1ZSkgPCBhbW91bnQpIHtcbiAgICAgIGlmICghdGhpcy5wdXNoSGFuZGxlT25lUG9pbnQoYm91bmRzLCBoYW5kbGUsIGRpcmVjdGlvbikpIHtcbiAgICAgICAgLy8gY2FuJ3QgcHVzaCBoYW5kbGUgZW5vdWdoIHRvIGNyZWF0ZSB0aGUgbmVlZGVkIGBhbW91bnRgIGdhcCwgc28gd2VcbiAgICAgICAgLy8gcmV2ZXJ0IGl0cyBwb3NpdGlvbiB0byB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgYm91bmRzW2hhbmRsZV0gPSBvcmlnaW5hbFZhbHVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjdXJyZW50VmFsdWUgPSBib3VuZHNbaGFuZGxlXTtcbiAgICB9XG4gICAgLy8gdGhlIGhhbmRsZSB3YXMgcHVzaGVkIGVub3VnaCB0byBjcmVhdGUgdGhlIG5lZWRlZCBgYW1vdW50YCBnYXBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHB1c2hIYW5kbGVPbmVQb2ludChib3VuZHMsIGhhbmRsZSwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKTtcbiAgICBjb25zdCBwb2ludEluZGV4ID0gcG9pbnRzLmluZGV4T2YoYm91bmRzW2hhbmRsZV0pO1xuICAgIGNvbnN0IG5leHRQb2ludEluZGV4ID0gcG9pbnRJbmRleCArIGRpcmVjdGlvbjtcbiAgICBpZiAobmV4dFBvaW50SW5kZXggPj0gcG9pbnRzLmxlbmd0aCB8fCBuZXh0UG9pbnRJbmRleCA8IDApIHtcbiAgICAgIC8vIHJlYWNoZWQgdGhlIG1pbmltdW0gb3IgbWF4aW11bSBhdmFpbGFibGUgcG9pbnQsIGNhbid0IHB1c2ggYW55bW9yZVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBuZXh0SGFuZGxlID0gaGFuZGxlICsgZGlyZWN0aW9uO1xuICAgIGNvbnN0IG5leHRWYWx1ZSA9IHBvaW50c1tuZXh0UG9pbnRJbmRleF07XG4gICAgY29uc3QgeyBwdXNoYWJsZTogdGhyZXNob2xkIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGRpZmZUb05leHQgPSBkaXJlY3Rpb24gKiAoYm91bmRzW25leHRIYW5kbGVdIC0gbmV4dFZhbHVlKTtcbiAgICBpZiAoIXRoaXMucHVzaEhhbmRsZShib3VuZHMsIG5leHRIYW5kbGUsIGRpcmVjdGlvbiwgdGhyZXNob2xkIC0gZGlmZlRvTmV4dCkpIHtcbiAgICAgIC8vIGNvdWxkbid0IHB1c2ggbmV4dCBoYW5kbGUsIHNvIHdlIHdvbid0IHB1c2ggdGhpcyBvbmUgZWl0aGVyXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHB1c2ggdGhlIGhhbmRsZVxuICAgIGJvdW5kc1toYW5kbGVdID0gbmV4dFZhbHVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdHJpbUFsaWduVmFsdWUodiwgaGFuZGxlLCBuZXh0UHJvcHMgPSB7fSkge1xuICAgIGNvbnN0IG1lcmdlZFByb3BzID0geyAuLi50aGlzLnByb3BzLCAuLi5uZXh0UHJvcHMgfTtcbiAgICBjb25zdCB2YWxJblJhbmdlID0gdXRpbHMuZW5zdXJlVmFsdWVJblJhbmdlKHYsIG1lcmdlZFByb3BzKTtcbiAgICBjb25zdCB2YWxOb3RDb25mbGljdCA9IHRoaXMuZW5zdXJlVmFsdWVOb3RDb25mbGljdChoYW5kbGUsIHZhbEluUmFuZ2UsIG1lcmdlZFByb3BzKTtcbiAgICByZXR1cm4gdXRpbHMuZW5zdXJlVmFsdWVQcmVjaXNpb24odmFsTm90Q29uZmxpY3QsIG1lcmdlZFByb3BzKTtcbiAgfVxuXG4gIGVuc3VyZVZhbHVlTm90Q29uZmxpY3QoaGFuZGxlLCB2YWwsIHsgYWxsb3dDcm9zcywgcHVzaGFibGU6IHRoZXJzaG9sZCB9KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlIHx8IHt9O1xuICAgIGNvbnN0IHsgYm91bmRzIH0gPSBzdGF0ZTtcbiAgICBoYW5kbGUgPSBoYW5kbGUgPT09IHVuZGVmaW5lZCA/IHN0YXRlLmhhbmRsZSA6IGhhbmRsZTtcbiAgICB0aGVyc2hvbGQgPSBOdW1iZXIodGhlcnNob2xkKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgICBpZiAoIWFsbG93Q3Jvc3MgJiYgaGFuZGxlICE9IG51bGwgJiYgYm91bmRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChoYW5kbGUgPiAwICYmIHZhbCA8PSAoYm91bmRzW2hhbmRsZSAtIDFdICsgdGhlcnNob2xkKSkge1xuICAgICAgICByZXR1cm4gYm91bmRzW2hhbmRsZSAtIDFdICsgdGhlcnNob2xkO1xuICAgICAgfVxuICAgICAgaWYgKGhhbmRsZSA8IGJvdW5kcy5sZW5ndGggLSAxICYmIHZhbCA+PSAoYm91bmRzW2hhbmRsZSArIDFdIC0gdGhlcnNob2xkKSkge1xuICAgICAgICByZXR1cm4gYm91bmRzW2hhbmRsZSArIDFdIC0gdGhlcnNob2xkO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGFuZGxlLFxuICAgICAgYm91bmRzLFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHtcbiAgICAgIHByZWZpeENscyxcbiAgICAgIHZlcnRpY2FsLFxuICAgICAgaW5jbHVkZWQsXG4gICAgICBkaXNhYmxlZCxcbiAgICAgIG1pbixcbiAgICAgIG1heCxcbiAgICAgIGhhbmRsZTogaGFuZGxlR2VuZXJhdG9yLFxuICAgICAgdHJhY2tTdHlsZSxcbiAgICAgIGhhbmRsZVN0eWxlLFxuICAgICAgdGFiSW5kZXgsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBvZmZzZXRzID0gYm91bmRzLm1hcCh2ID0+IHRoaXMuY2FsY09mZnNldCh2KSk7XG5cbiAgICBjb25zdCBoYW5kbGVDbGFzc05hbWUgPSBgJHtwcmVmaXhDbHN9LWhhbmRsZWA7XG4gICAgY29uc3QgaGFuZGxlcyA9IGJvdW5kcy5tYXAoKHYsIGkpID0+IGhhbmRsZUdlbmVyYXRvcih7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoe1xuICAgICAgICBbaGFuZGxlQ2xhc3NOYW1lXTogdHJ1ZSxcbiAgICAgICAgW2Ake2hhbmRsZUNsYXNzTmFtZX0tJHtpICsgMX1gXTogdHJ1ZSxcbiAgICAgIH0pLFxuICAgICAgcHJlZml4Q2xzLFxuICAgICAgdmVydGljYWwsXG4gICAgICBvZmZzZXQ6IG9mZnNldHNbaV0sXG4gICAgICB2YWx1ZTogdixcbiAgICAgIGRyYWdnaW5nOiBoYW5kbGUgPT09IGksXG4gICAgICBpbmRleDogaSxcbiAgICAgIHRhYkluZGV4OiB0YWJJbmRleFtpXSB8fCAwLFxuICAgICAgbWluLFxuICAgICAgbWF4LFxuICAgICAgZGlzYWJsZWQsXG4gICAgICBzdHlsZTogaGFuZGxlU3R5bGVbaV0sXG4gICAgICByZWY6IGggPT4gdGhpcy5zYXZlSGFuZGxlKGksIGgpLFxuICAgIH0pKTtcblxuICAgIGNvbnN0IHRyYWNrcyA9IGJvdW5kcy5zbGljZSgwLCAtMSkubWFwKChfLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgaSA9IGluZGV4ICsgMTtcbiAgICAgIGNvbnN0IHRyYWNrQ2xhc3NOYW1lID0gY2xhc3NOYW1lcyh7XG4gICAgICAgIFtgJHtwcmVmaXhDbHN9LXRyYWNrYF06IHRydWUsXG4gICAgICAgIFtgJHtwcmVmaXhDbHN9LXRyYWNrLSR7aX1gXTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPFRyYWNrXG4gICAgICAgICAgY2xhc3NOYW1lPXt0cmFja0NsYXNzTmFtZX1cbiAgICAgICAgICB2ZXJ0aWNhbD17dmVydGljYWx9XG4gICAgICAgICAgaW5jbHVkZWQ9e2luY2x1ZGVkfVxuICAgICAgICAgIG9mZnNldD17b2Zmc2V0c1tpIC0gMV19XG4gICAgICAgICAgbGVuZ3RoPXtvZmZzZXRzW2ldIC0gb2Zmc2V0c1tpIC0gMV19XG4gICAgICAgICAgc3R5bGU9e3RyYWNrU3R5bGVbaW5kZXhdfVxuICAgICAgICAgIGtleT17aX1cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyB0cmFja3MsIGhhbmRsZXMgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTbGlkZXIoUmFuZ2UpO1xuIl19